-- This file is auto generated by pgx.
-- `extension_sql!()` defined SQL.


-- Enums derived via `#[derive(PostgresEnum)]`


-- Shell types for types defined by `#[derive(PostgresType)]`

-- src/lib.rs:41
-- schemas::pg_catalog::MyPgCatalogType
-- schemas::pg_catalog::MyPgCatalogType - TypeId { t: 5607551422967041332 }
-- Option<schemas::pg_catalog::MyPgCatalogType> - TypeId { t: 2714998612296461429 }
-- Vec<schemas::pg_catalog::MyPgCatalogType> - TypeId { t: 15032736965277869111 }
CREATE TYPE pg_catalog.MyPgCatalogType;
-- src/lib.rs:24
-- schemas::some_schema::MySomeSchemaType
-- schemas::some_schema::MySomeSchemaType - TypeId { t: 10277978687532669753 }
-- Option<schemas::some_schema::MySomeSchemaType> - TypeId { t: 11681602971493109345 }
-- Vec<schemas::some_schema::MySomeSchemaType> - TypeId { t: 15223998649939794532 }
CREATE TYPE some_schema.MySomeSchemaType;
-- src/lib.rs:9
-- schemas::MyType
-- schemas::MyType - TypeId { t: 9128259095547779160 }
-- Option<schemas::MyType> - TypeId { t: 17863908836348541307 }
-- Vec<schemas::MyType> - TypeId { t: 15675420420976076206 }
CREATE TYPE pg_catalog.MyType;

-- Functions defined by `#[pg_extern]`

-- src/lib.rs:41
-- schemas::pg_catalog::mypgcatalogtype_out
CREATE OR REPLACE FUNCTION pg_catalog."mypgcatalogtype_out"(
	"input" MyPgCatalogType /* schemas::pg_catalog::MyPgCatalogType */
) RETURNS cstring /* &std::ffi::c_str::CStr */
IMMUTABLE PARALLEL SAFE STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mypgcatalogtype_out_wrapper';

-- src/lib.rs:41
-- schemas::pg_catalog::mypgcatalogtype_in
CREATE OR REPLACE FUNCTION pg_catalog."mypgcatalogtype_in"(
	"input" cstring /* &std::ffi::c_str::CStr */
) RETURNS MyPgCatalogType /* schemas::pg_catalog::MyPgCatalogType */
IMMUTABLE PARALLEL SAFE STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mypgcatalogtype_in_wrapper';

-- src/lib.rs:24
-- schemas::some_schema::mysomeschematype_out
CREATE OR REPLACE FUNCTION some_schema."mysomeschematype_out"(
	"input" MySomeSchemaType /* schemas::some_schema::MySomeSchemaType */
) RETURNS cstring /* &std::ffi::c_str::CStr */
IMMUTABLE PARALLEL SAFE STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mysomeschematype_out_wrapper';

-- src/lib.rs:24
-- schemas::some_schema::mysomeschematype_in
CREATE OR REPLACE FUNCTION some_schema."mysomeschematype_in"(
	"input" cstring /* &std::ffi::c_str::CStr */
) RETURNS MySomeSchemaType /* schemas::some_schema::MySomeSchemaType */
IMMUTABLE PARALLEL SAFE STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mysomeschematype_in_wrapper';

-- src/lib.rs:27
-- schemas::some_schema::hello_some_schema
CREATE OR REPLACE FUNCTION some_schema."hello_some_schema"() RETURNS text /* &str */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'hello_some_schema_wrapper';

-- src/lib.rs:51
-- schemas::public::hello_public
CREATE OR REPLACE FUNCTION public."hello_public"() RETURNS text /* &str */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'hello_public_wrapper';

-- src/lib.rs:12
-- schemas::hello_default_schema
CREATE OR REPLACE FUNCTION pg_catalog."hello_default_schema"() RETURNS text /* &str */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'hello_default_schema_wrapper';

-- src/lib.rs:9
-- schemas::mytype_out
CREATE OR REPLACE FUNCTION pg_catalog."mytype_out"(
	"input" MyType /* schemas::MyType */
) RETURNS cstring /* &std::ffi::c_str::CStr */
IMMUTABLE PARALLEL SAFE STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mytype_out_wrapper';

-- src/lib.rs:9
-- schemas::mytype_in
CREATE OR REPLACE FUNCTION pg_catalog."mytype_in"(
	"input" cstring /* &std::ffi::c_str::CStr */
) RETURNS MyType /* schemas::MyType */
IMMUTABLE PARALLEL SAFE STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mytype_in_wrapper';


-- Types defined by `#[derive(PostgresType)]`

-- src/lib.rs:41
-- schemas::pg_catalog::MyPgCatalogType - TypeId { t: 5607551422967041332 }
-- Option<schemas::pg_catalog::MyPgCatalogType> - TypeId { t: 2714998612296461429 }
-- Vec<schemas::pg_catalog::MyPgCatalogType> - TypeId { t: 15032736965277869111 }
CREATE TYPE pg_catalog.MyPgCatalogType (
	INTERNALLENGTH = variable,
	INPUT = mypgcatalogtype_in,
	OUTPUT = mypgcatalogtype_out,
	STORAGE = extended
);
                            
-- src/lib.rs:24
-- schemas::some_schema::MySomeSchemaType - TypeId { t: 10277978687532669753 }
-- Option<schemas::some_schema::MySomeSchemaType> - TypeId { t: 11681602971493109345 }
-- Vec<schemas::some_schema::MySomeSchemaType> - TypeId { t: 15223998649939794532 }
CREATE TYPE some_schema.MySomeSchemaType (
	INTERNALLENGTH = variable,
	INPUT = mysomeschematype_in,
	OUTPUT = mysomeschematype_out,
	STORAGE = extended
);
                            
-- src/lib.rs:9
-- schemas::MyType - TypeId { t: 9128259095547779160 }
-- Option<schemas::MyType> - TypeId { t: 17863908836348541307 }
-- Vec<schemas::MyType> - TypeId { t: 15675420420976076206 }
CREATE TYPE pg_catalog.MyType (
	INTERNALLENGTH = variable,
	INPUT = mytype_in,
	OUTPUT = mytype_out,
	STORAGE = extended
);
                            

-- Operator classes defined by `#[derive(PostgresHash, PostgresOrd)]`

